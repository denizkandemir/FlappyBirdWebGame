<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flappy Neon (Geometry‑Dash Style)</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #07081A;
      color: #E5ECFF;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    #wrap {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }

    canvas {
      display: block;
      background: radial-gradient(1200px 800px at 20% 10%, #12224a 0%, #0c1230 50%, #07081A 100%);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, .55);
    }

    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    .row {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .top {
      top: 12px;
    }

    .center {
      top: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .badge {
      background: rgba(10, 14, 40, .6);
      border: 1px solid rgba(229, 236, 255, .12);
      padding: 8px 12px;
      border-radius: 999px;
      pointer-events: none;
      font-weight: 700;
      backdrop-filter: blur(6px);
    }

    .btn {
      pointer-events: auto;
      background: #7CFC00;
      color: #021;
      border: none;
      padding: 10px 16px;
      border-radius: 10px;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 6px 16px rgba(124, 252, 0, .35);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .muted {
      opacity: .85;
      font-weight: 600;
    }

    .big {
      font-size: 22px;
    }

    .title {
      font-size: clamp(22px, 5vw, 36px);
      font-weight: 900;
      letter-spacing: .6px;
      margin-bottom: 8px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, .35);
    }

    .subtitle {
      font-size: clamp(14px, 3vw, 18px);
      opacity: .9;
    }

    .footer {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      opacity: .7;
    }
  </style>
</head>

<body>
  <div id="wrap"><canvas id="game"></canvas></div>
  <div class="hud">
    <div class="row top">
      <div id="score" class="badge big">Skor: 0</div>
      <div id="best" class="badge">Rekor: 0</div>
      <button id="pauseBtn" class="btn" style="display:none">Duraklat</button>
    </div>
    <div id="overlay" class="center" style="display:grid; gap:14px;">
      <div class="title">FLAPPY NEON</div>
      <div class="subtitle muted">Geometry‑Dash tarzı neon görseller · <b>Boşluk/Tıkla/Dokun</b> ile zıpla</div>
      <div><button id="playBtn" class="btn">Başla</button></div>
    </div>
    <div class="footer muted">Flappy oynanış · GD neon estetik — © 2025</div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // HiDPI & responsive
      const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      function resize() {
        const margin = 12; const w = Math.min(window.innerWidth - margin * 2, 560); const h = Math.min(window.innerHeight - margin * 2, 900);
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = Math.floor(w * DPR); canvas.height = Math.floor(h * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }
      resize(); window.addEventListener('resize', resize);

      // Colors (Neon palette)
      const C = {
        grid: 'rgba(120,160,255,0.10)',
        player: '#00E5FF',
        trail: '#00C2FF',
        pillar: '#8AFF00',
        hazard: '#FF2E63',
        coin: '#FFD166'
      };

      // Game constants (Flappy physics)
      const G = 1500;            // gravity px/s^2
      const FLAP_V = -420;       // impulse
      const PIPE_GAP = 170;      // gap size
      const PIPE_W = 80;         // pillar width
      const SPEED = 170;         // pipe speed (px/s)
      const SPAWN_MS = 1300;     // spawn interval
      const FLOOR_H = 72;        // visual floor line

      // State
      let state = 'ready';
      let score = 0; let best = Number(localStorage.getItem('flappy_neon_best') || '0') || 0;
      document.getElementById('best').textContent = 'Rekor: ' + best;

      const world = { W: 0, H: 0 };
      function W() { return canvas.width / DPR } function H() { return canvas.height / DPR }

      // Player: cube with glow + trail
      const player = {
        x: 120,
        y: 0,
        s: 32, // size
        vy: 0,
        trail: [],
        reset() { this.x = 120; this.y = H() / 2; this.vy = 0; this.trail.length = 0; },
        flap() { this.vy = FLAP_V; pulse(); }
      };

      // Pipes (neon pillars)
      /** item: {x, topH, passed:false} */
      const pipes = [];
      let spawnTimer = 0, last = performance.now(), tPulse = 0, t = performance.now();

      // UI helpers
      const overlayEl = document.getElementById('overlay'); const pauseBtn = document.getElementById('pauseBtn');
      const overlay = {
        hide() { overlayEl.style.display = 'none'; },
        showStart() {
          overlayEl.style.display = 'grid'; overlayEl.innerHTML = `
        <div class="title">FLAPPY NEON</div>
        <div class="subtitle muted">Zıplamak için <b>Boşluk</b> / <b>Tıkla</b> / <b>Dokun</b></div>
        <div><button id="playBtn" class="btn">Başla</button></div>`; overlayEl.querySelector('#playBtn').onclick = startGame;
        },
        showPaused() { overlayEl.style.display = 'grid'; overlayEl.innerHTML = `<div class="title">Duraklatıldı</div><div class="subtitle muted">Devam: <b>Boşluk/Tıkla</b></div>`; },
        showGameOver(s, b) {
          overlayEl.style.display = 'grid'; overlayEl.innerHTML = `
        <div class="title">Oyun Bitti</div>
        <div class="subtitle">Skor: <b>${s}</b> · Rekor: <b>${b}</b></div>
        <div style="display:flex; gap:10px; justify-content:center;">
          <button id="retryBtn" class="btn">Tekrar</button>
          <button id="menuBtn" class="btn" style="background:#60a5fa; box-shadow:0 6px 14px rgba(96,165,250,.35)">Menü</button>
        </div>`; overlayEl.querySelector('#retryBtn').onclick = () => { resetGame(); startGame(); }; overlayEl.querySelector('#menuBtn').onclick = () => { resetGame(); };
        }
      };

      function setScore() { document.getElementById('score').textContent = 'Skor: ' + score; document.getElementById('best').textContent = 'Rekor: ' + best; }

      function resetGame() { score = 0; setScore(); pipes.length = 0; spawnTimer = 0; player.reset(); state = 'ready'; overlay.showStart(); pauseBtn.style.display = 'none'; }
      function startGame() { if (state === 'playing') return; state = 'playing'; overlay.hide(); last = performance.now(); pauseBtn.textContent = 'Duraklat'; pauseBtn.style.display = 'inline-block'; loop(); }
      function gameOver() { state = 'gameover'; if (score > best) { best = score; localStorage.setItem('flappy_neon_best', String(best)); } overlay.showGameOver(score, best); pauseBtn.style.display = 'none'; }
      function togglePause() { if (state === 'playing') { state = 'paused'; overlay.showPaused(); } else if (state === 'paused') { state = 'playing'; overlay.hide(); last = performance.now(); loop(); } }

      // Input
      function primary() { if (state === 'ready') return startGame(); if (state === 'playing') player.flap(); else if (state === 'paused') togglePause(); else if (state === 'gameover') { resetGame(); startGame(); } }
      window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); primary(); } if (e.code === 'KeyP') togglePause(); }, { passive: false });
      window.addEventListener('mousedown', primary); window.addEventListener('touchstart', (e) => { e.preventDefault(); primary(); }, { passive: false });
      pauseBtn.addEventListener('click', togglePause);

      // Loop
      function loop(ts) { if (state !== 'playing') return; const now = ts ?? performance.now(); let dt = (now - last) / 1000; dt = Math.min(dt, 1 / 30); last = now; t = now; update(dt); draw(); requestAnimationFrame(loop); }

      function update(dt) {
        // spawn pillars
        spawnTimer += dt * 1000; if (spawnTimer >= SPAWN_MS) { spawnTimer = 0; const h = H(); const minTop = 60; const maxTop = h - FLOOR_H - 60 - PIPE_GAP; const topH = Math.max(minTop, Math.min(maxTop, minTop + Math.random() * (maxTop - minTop))); pipes.push({ x: W() + 40, topH, passed: false }); }

        // move pillars & scoring
        for (let i = pipes.length - 1; i >= 0; i--) { const p = pipes[i]; p.x -= SPEED * dt; if (!p.passed && p.x + PIPE_W < player.x - player.s / 2) { p.passed = true; score++; setScore(); } if (p.x + PIPE_W < -50) pipes.splice(i, 1); }

        // physics
        player.vy += G * dt; player.y += player.vy * dt;

        // bounds & ground line as hazard
        if (player.y - player.s / 2 < 0) { player.y = player.s / 2; player.vy = 0; }
        if (player.y + player.s / 2 > H() - FLOOR_H) { player.y = H() - FLOOR_H - player.s / 2; return gameOver(); }

        // collisions
        for (const p of pipes) {
          const gapTop = p.topH; const gapBottom = p.topH + PIPE_GAP; // pillars occupy [0..gapTop] and [gapBottom..H-FLOOR_H]
          // player AABB
          const px = player.x - player.s / 2, py = player.y - player.s / 2, ps = player.s;
          // top pillar
          if (aabb(px, py, ps, ps, p.x, 0, PIPE_W, gapTop) || aabb(px, py, ps, ps, p.x, gapBottom, PIPE_W, (H() - FLOOR_H) - gapBottom)) return gameOver();
        }

        // trail
        player.trail.push({ x: player.x, y: player.y, t: 0 }); while (player.trail.length > 24) player.trail.shift(); for (const tr of player.trail) tr.t += dt;

        // pulse
        tPulse += dt;
      }

      // Utils
      function aabb(x1, y1, w1, h1, x2, y2, w2, h2) { return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2; }
      function hexA(hex, a) { const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return `rgba(${r},${g},${b},${a})`; }
      function pulse() { tPulse = 0; }

      // Drawing
      function draw() {
        const w = W(), h = H(); ctx.clearRect(0, 0, w, h); drawBackGrid(w, h);
        // floor neon line
        ctx.save(); const lineColor = `hsl(${(t / 20) % 360} 90% 60%)`; ctx.strokeStyle = lineColor; ctx.lineWidth = 4; ctx.shadowBlur = 14; ctx.shadowColor = lineColor; ctx.beginPath(); ctx.moveTo(0, h - FLOOR_H + 0.5); ctx.lineTo(w, h - FLOOR_H + 0.5); ctx.stroke(); ctx.restore();

        // pillars
        for (const p of pipes) {
          drawNeonRect(p.x, 0, PIPE_W, p.topH, C.pillar); const gapBottom = p.topH + PIPE_GAP; drawNeonRect(p.x, gapBottom, PIPE_W, (h - FLOOR_H) - gapBottom, C.pillar); // hazard teeth on rims
          drawTeeth(p.x, p.topH, PIPE_W, true); drawTeeth(p.x, gapBottom, PIPE_W, false);
        }

        // player trail
        ctx.save(); ctx.globalCompositeOperation = 'lighter'; for (let i = 0; i < player.trail.length; i++) { const tr = player.trail[i]; const a = Math.max(0, 0.35 - i * 0.015); if (a <= 0) continue; ctx.fillStyle = hexA(C.trail, a); ctx.beginPath(); ctx.arc(tr.x, tr.y, 6, 0, Math.PI * 2); ctx.fill(); } ctx.restore();

        // player cube with neon stroke & pulse
        const s = player.s * (1 + 0.05 * Math.sin(tPulse * 20)); drawPlayer(player.x - s / 2, player.y - s / 2, s, s);

        // center score
        if (state === 'playing') { ctx.save(); ctx.globalAlpha = .25; ctx.fillStyle = '#fff'; ctx.font = '900 64px system-ui,-apple-system,Segoe UI,Roboto'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText(String(score), w / 2, 12); ctx.restore(); }
      }

      function drawBackGrid(Wi, Hi) { ctx.save(); ctx.strokeStyle = C.grid; ctx.lineWidth = 1; const s = 32; const offset = (t * 0.06) % s; for (let x = -s + offset; x < Wi; x += s) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, Hi); ctx.stroke(); } for (let y = -s + offset; y < Hi; y += s) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(Wi, y); ctx.stroke(); } ctx.restore(); }

      function drawNeonRect(x, y, w, h, color) { ctx.save(); ctx.fillStyle = hexA(color, .18); ctx.fillRect(x, y, w, h); ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.shadowColor = color; ctx.shadowBlur = 12; ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1); ctx.restore(); }

      function drawTeeth(x, edgeY, w, downwards) { // small triangular teeth to feel "hazard"
        const toothW = 12, toothH = 10; const count = Math.floor(w / toothW);
        for (let i = 0; i < count; i++) { const tx = x + i * toothW; const ty = downwards ? edgeY : edgeY; drawNeonTri(tx, ty, toothW, toothH * (downwards ? 1 : -1)); }
      }

      function drawNeonTri(x, y, base, h) { // if h>0 triangle points downwards, else upwards
        const color = C.hazard; ctx.save(); ctx.fillStyle = hexA(color, .18); ctx.strokeStyle = color; ctx.lineWidth = 2.5; ctx.shadowColor = color; ctx.shadowBlur = 10; ctx.beginPath(); if (h > 0) { ctx.moveTo(x, y); ctx.lineTo(x + base, y); ctx.lineTo(x + base / 2, y + h); } else { ctx.moveTo(x, y); ctx.lineTo(x + base, y); ctx.lineTo(x + base / 2, y + h); } ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
      }

      function drawPlayer(x, y, w, h) {
        drawNeonRect(x, y, w, h, C.player); // "face"
        ctx.save(); ctx.fillStyle = '#fff'; const eye = 6; ctx.fillRect(x + w * 0.22, y + h * 0.32, 6, 8); ctx.fillRect(x + w * 0.42, y + h * 0.32, 6, 8); ctx.fillRect(x + w * 0.22, y + h * 0.64, w * 0.56, 4); ctx.restore();
      }

      // Init
      resetGame();
    })();
  </script>
</body>

</html>